// --- ì „ì—­ ë³€ìˆ˜ ---
console.log('Script.js ë¡œë“œë¨');
var map = null;
var _lastState = {
  id: '',
  type: '',
  layer: '',
  coords: '',
  element: null,
  feature: null,
  attributes: null,
  ageGroup: 'ì •ë³´ ì—†ìŒ',
  appliedStyle: null
};
var _highlightTimeout = null;
var _HIGHLIGHT_DELAY = 120;
var DEBUG = true;
var VWORLD_API_KEY = '3907B382-CD3D-304B-A82F-C7BFA4286232';
var _lastAddressRequestId = 0;
const _dataCache = new Map();

// ë…¸í›„ë„ ìƒ‰ìƒ íŒ”ë ˆíŠ¸
const AGE_COLOR_MAP = {
  '0~9ë…„': [255, 179, 179, 1],
  '10~20ë…„': [255, 128, 128, 1],
  '20~30ë…„': [255, 77, 77, 1],
  '30ë…„ì´ìƒ': [217, 31, 31, 1],
  'ì •ë³´ ì—†ìŒ': [255, 230, 128, 1],
  'ì˜¤ë¥˜': [200, 200, 200, 1]
};

function getAgeColor(ageGroup) {
  return AGE_COLOR_MAP[ageGroup] || AGE_COLOR_MAP['ì •ë³´ ì—†ìŒ'];
}

function buildColorTokens(ageGroup) {
  const rgba = getAgeColor(ageGroup) || AGE_COLOR_MAP['ì •ë³´ ì—†ìŒ'];
  const rgbaString = `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3]})`;
  let vwColor = null;
  let wsColor = null;
  let styleExpr = null;
  let cesiumColor = null;
  try {
    if (typeof vw !== 'undefined' && typeof vw.Color === 'function') {
      const r = rgba[0] / 255;
      const g = rgba[1] / 255;
      const b = rgba[2] / 255;
      const a = rgba[3];
      vwColor = new vw.Color(r, g, b, a);
      wsColor = vwColor.ws3dColor;
    }
    if (typeof vw !== 'undefined' && vw.StyleExpression && typeof vw.StyleExpression.color === 'function') {
      styleExpr = vw.StyleExpression.color(rgbaString);
    }
  } catch (e) {
    if (DEBUG) console.warn('buildColorTokens vw.Color error', e);
  }
  try {
    if (typeof Cesium !== 'undefined' && Cesium.Color && typeof Cesium.Color.fromCssColorString === 'function') {
      cesiumColor = Cesium.Color.fromCssColorString(rgbaString);
    }
  } catch (e) {
    if (DEBUG) console.warn('buildColorTokens Cesium.Color error', e);
  }
  const colorExpression = `color("${rgbaString}")`;
  const colorProxy = {
    toCssColorString: () => rgbaString,
    evaluateColor: () => {
      if (cesiumColor) return cesiumColor;
      return {
        toCssColorString: () => rgbaString
      };
    },
    clone: () => colorProxy,
    toString: () => rgbaString
  };
  return { rgba, rgbaString, colorExpression, vwColor, wsColor, styleExpr, cesiumColor, colorProxy };
}

function buildHighlightKey(attributes) {
  if (!attributes || typeof attributes !== 'object') return null;
  const key = {};
  if (attributes.__OID__) key.__OID__ = attributes.__OID__;
  if (attributes.TD_ID) key.TD_ID = attributes.TD_ID;
  if (attributes.MODEL_NAME) key.MODEL_NAME = attributes.MODEL_NAME;
  if (attributes.ID) key.ID = attributes.ID;
  if (attributes.FID) key.FID = attributes.FID;
  if (attributes.OBJECTID) key.OBJECTID = attributes.OBJECTID;
  if (attributes.GID) key.GID = attributes.GID;
  if (!key.MODEL_NAME && attributes.NAME) key.NAME = attributes.NAME;
  return Object.keys(key).length ? key : null;
}

function toFeatureCandidate(obj) {
  if (!obj) return null;
  if (typeof obj.setStyle === 'function' || typeof obj.setOptions === 'function') return obj;
  if (obj.feature) return toFeatureCandidate(obj.feature);
  if (Array.isArray(obj.featureInfos) && obj.featureInfos.length) {
    for (const fi of obj.featureInfos) {
      const candidate = toFeatureCandidate(fi?.feature || fi?.element || fi);
      if (candidate) return candidate;
    }
  }
  if (obj.featureInfo) return toFeatureCandidate(obj.featureInfo.feature || obj.featureInfo.element || obj.featureInfo);
  if (obj.element) return toFeatureCandidate(obj.element);
  return null;
}

function getFeatureAttributes(feature, fallbackAttrs) {
  if (!feature && !fallbackAttrs) return null;
  if (feature?.attributes) return feature.attributes;
  if (typeof feature?.getAttributes === 'function') {
    try { return feature.getAttributes(); } catch (e) { if (DEBUG) console.warn('getAttributes error', e); }
  }
  return fallbackAttrs || null;
}

function safeClearHighlight(element, appliedInfo) {
  if (!element) return;
  if (appliedInfo?.method === 'feature.setStyle' && appliedInfo.target) {
    try { safeClearHighlight(appliedInfo.target, appliedInfo.applied); }
    catch (e) { if (DEBUG) console.warn('nested safeClearHighlight error', e); }
  }

  const shouldClearHighlight = !appliedInfo || appliedInfo.method === 'highlightFeatureByKey' || appliedInfo.method === 'highlightFeature';
  if (shouldClearHighlight && typeof element.clearHighlightedFeatures === 'function') {
    try { element.clearHighlightedFeatures(); }
    catch (e) { if (DEBUG) console.warn('clearHighlightedFeatures error', e); }
  }
  if (appliedInfo?.usedSetStyle && typeof element.setStyle === 'function') {
    try { element.setStyle(null); }
    catch (e) { if (DEBUG) console.warn('setStyle reset error', e); }
  }
  if (appliedInfo?.usedSetOptions && typeof element.setOptions === 'function') {
    try { element.setOptions({ outline: false }); }
    catch (e) { if (DEBUG) console.warn('setOptions reset error', e); }
  }
}

function applyElementColorByAge(element, ageGroup, attributes, prebuiltTokens) {
  if (!element) return null;
  const tokens = prebuiltTokens || buildColorTokens(ageGroup);
  let appliedInfo = null;
  const optionColor = tokens.colorExpression;

  if (typeof element.setStyle === 'function') {
    try {
      element.setStyle({
        color: optionColor,
        outline: true,
        outlineColor: optionColor,
        material: optionColor,
        materialColor: optionColor
      });
      appliedInfo = { method: 'setStyle', usedSetStyle: true, ageGroup, color: optionColor };
      return appliedInfo;
    } catch (e) {
      if (DEBUG) console.warn('setStyle fallback error', e);
    }
  }

  if (typeof element.setOptions === 'function') {
    try {
      element.setOptions({
        outline: true,
        outlineColor: optionColor,
        material: optionColor,
        materialColor: optionColor,
        color: optionColor,
        fillColor: optionColor
      });
      appliedInfo = { method: 'setOptions', usedSetOptions: true, ageGroup, color: optionColor };
      return appliedInfo;
    } catch (e) {
      if (DEBUG) console.warn('setOptions fallback error', e);
    }
  }

  return appliedInfo;
}

function normalizeAgeValue(rawAge) {
  if (rawAge == null || rawAge === '') return null;
  if (typeof rawAge === 'number') return isFinite(rawAge) ? rawAge : null;
  const parsed = parseFloat(String(rawAge).replace(/[^0-9.\-]/g, ''));
  return isFinite(parsed) ? parsed : null;
}

function getAgeGroup(age) {
  if (age == null || !isFinite(age)) return 'ì •ë³´ ì—†ìŒ';
  if (age < 0) return 'ì˜¤ë¥˜';
  if (age <= 9) return '0~9ë…„';
  if (age <= 20) return '10~20ë…„';
  if (age <= 30) return '20~30ë…„';
  return '30ë…„ì´ìƒ';
}

function rememberSelection(element, feature, attributes) {
  const resolvedElement = element || feature;
  const resolvedFeature = feature || element || null;
  if (!resolvedElement && !resolvedFeature) return;

  // ì´ì „ ì„ íƒ í•´ì œ
  if (_lastState.appliedStyle && _lastState.element) {
    safeClearHighlight(_lastState.element, _lastState.appliedStyle);
  }

  _lastState.element = resolvedElement;
  _lastState.feature = resolvedFeature;
  _lastState.attributes = attributes || null;
  _lastState.ageGroup = 'ì •ë³´ ì—†ìŒ';
  _lastState.appliedStyle = null;
}

// âœ… í•µì‹¬: ê°œë³„ ê±´ë¬¼ë§Œ í•˜ì´ë¼ì´íŠ¸ (ì „ì²´ ë ˆì´ì–´ ìƒ‰ìƒ ë³€ê²½ ì ˆëŒ€ ê¸ˆì§€)
function applySelectionHighlight(ageGroup, explicitFeature) {
  const element = _lastState.element || null;
  const feature = explicitFeature || _lastState.feature || null;
  const attrs = getFeatureAttributes(feature, _lastState.attributes) || _lastState.attributes || null;
  
  if (!element) {
    console.warn('âš ï¸ elementê°€ ì—†ì–´ì„œ í•˜ì´ë¼ì´íŠ¸ ë¶ˆê°€');
    return;
  }

  if (!attrs) {
    console.warn('âš ï¸ attributesê°€ ì—†ì–´ì„œ í•˜ì´ë¼ì´íŠ¸ ë¶ˆê°€');
    return;
  }

  // í•˜ì´ë¼ì´íŠ¸ í‚¤ ìƒì„± (ê±´ë¬¼ ì‹ë³„ìš©)
  const key = buildHighlightKey(attrs);
  if (!key) {
    console.warn('âš ï¸ í•˜ì´ë¼ì´íŠ¸ í‚¤ ìƒì„± ì‹¤íŒ¨ - ê°œë³„ ê±´ë¬¼ ì‹ë³„ ë¶ˆê°€ëŠ¥');
    console.log('attributes:', attrs);
    return;
  }

  console.log('ğŸ” í•˜ì´ë¼ì´íŠ¸ ì‹œë„ - key:', key);

  const tokens = buildColorTokens(ageGroup);
  const highlightColor = tokens.styleExpr || tokens.cesiumColor || tokens.wsColor || tokens.colorProxy;
  const highlightOptions = {
    color: highlightColor,
    highlightColor,
    outline: true,
    outlineColor: highlightColor,
    material: highlightColor
  };

  // âœ… ë°©ë²• 1: highlightFeatureByKey (ê°€ì¥ ì•ˆì „)
  if (typeof element.highlightFeatureByKey === 'function') {
    try {
      element.highlightFeatureByKey(key, highlightOptions);
      _lastState.appliedStyle = {
        method: 'highlightFeatureByKey',
        highlightKey: key,
        ageGroup
      };
      _lastState.ageGroup = ageGroup;
      console.log('âœ… highlightFeatureByKey ì„±ê³µ!');
      return;
    } catch (e) {
      console.warn('highlightFeatureByKey ì‹¤íŒ¨:', e);
    }
  }

  // âœ… ë°©ë²• 2: highlightFeature
  if (typeof element.highlightFeature === 'function') {
    try {
      element.highlightFeature(key, highlightOptions);
      _lastState.appliedStyle = {
        method: 'highlightFeature',
        highlightKey: key,
        ageGroup
      };
      _lastState.ageGroup = ageGroup;
      console.log('âœ… highlightFeature ì„±ê³µ!');
      return;
    } catch (e) {
      console.warn('highlightFeature ì‹¤íŒ¨:', e);
    }
  }

  if (feature) {
    const applied = applyElementColorByAge(feature, ageGroup, attrs, tokens);
    if (applied) {
      _lastState.appliedStyle = Object.assign({}, applied, { method: applied.method || 'feature.setStyle_or_setOptions', target: feature, ageGroup, applied });
      _lastState.feature = feature;
      _lastState.ageGroup = ageGroup;
      return;
    }
  }

  // âŒ ëª¨ë“  ë°©ë²• ì‹¤íŒ¨ - ì „ì²´ ë ˆì´ì–´ ìƒ‰ìƒ ë³€ê²½ ë°©ì§€ë¥¼ ìœ„í•´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
  console.error('âŒ ê°œë³„ ê±´ë¬¼ í•˜ì´ë¼ì´íŠ¸ ì‹¤íŒ¨ - ì „ì²´ ë ˆì´ì–´ ìƒ‰ìƒ ë³€ê²½ ë°©ì§€ë¥¼ ìœ„í•´ skip');
  console.log('- element:', element);
  console.log('- key:', key);
  console.log('- available methods:', {
    highlightFeatureByKey: typeof element.highlightFeatureByKey,
    highlightFeature: typeof element.highlightFeature,
    setStyle: typeof element.setStyle,
    setOptions: typeof element.setOptions
  });
  console.log('- highlightOptions type:', {
    colorType: typeof highlightOptions.color,
    hasEvaluateColor: typeof highlightOptions.color?.evaluateColor,
    hasToCss: typeof highlightOptions.color?.toCssColorString
  });
  _lastState.feature = feature || element;
  _lastState.ageGroup = ageGroup;
}

function restorePreviousSelection() {
  if (_lastState.appliedStyle && _lastState.element) {
    safeClearHighlight(_lastState.element, _lastState.appliedStyle);
  }
  _lastState.element = null;
  _lastState.attributes = null;
  _lastState.ageGroup = 'ì •ë³´ ì—†ìŒ';
  _lastState.id = '';
  _lastState.coords = '';
  _lastState.appliedStyle = null;
}

var searchMarkers = [];
const SEARCH_MARKER_IMAGE = '/map_img/search-pin.png';
const SEARCH_MARKER_SIZE = { w: 24, h: 24 };
const SEARCH_MAX_MARKERS = 1;
const DEDUPE_EPS = 0.0005;

function $id(id) { return document.getElementById(id); }
function escapeHtml(str) {
  if (str == null) return '';
  return String(str)
    .replace(/&/g, '&amp;').replace(/</g, '&lt;')
    .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

async function fallbackPoiSearch(keyword) {
  try {
    const params = new URLSearchParams({
      query: keyword,
      size: '1',
      page: '1',
      type: 'place',
      category: 'POI',
      domain: 'poi'
    });

    const response = await fetch(`/api/search_address?${params.toString()}`);
    if (!response.ok) return null;

    const data = await response.json();
    if (data?.error) {
      console.warn('POI ê²€ìƒ‰ í”„ë¡ì‹œ ì˜¤ë¥˜:', data.error);
      return null;
    }

    const items = data?.response?.result?.items;
    if (!Array.isArray(items) || !items.length) return null;

    const first = items[0];
    if (!first?.point) return null;

    const lon = Number(first.point.x);
    const lat = Number(first.point.y);
    if (!isFinite(lon) || !isFinite(lat)) return null;

    const addr = first.address || {};
    const road = addr.road || addr.roadAddress || '';
    const parcel = addr.parcel || addr.parcelAddress || '';
    const full = addr.full || first.title || [road, parcel].filter(Boolean).join(' ') || keyword;

    return {
      point: { x: lon, y: lat },
      title: first.title || keyword,
      address: { road, parcel, full }
    };
  } catch (e) {
    console.error('POI fallback ì˜¤ë¥˜:', e);
    return null;
  }
}

function initializeMap() {
  console.log('ì§€ë„ ì´ˆê¸°í™” ì‹œì‘...');
  if (typeof vw === 'undefined' || !vw.Map) {
    console.error('VWorld APIê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    return false;
  }

  try {
    if (window.map) {
      if (typeof window.map.destroy === 'function') window.map.destroy();
      else if (typeof window.map.dispose === 'function') window.map.dispose();
      window.map = null;
      map = null;
    }

    var defaultLon = 127.3845;
    var defaultLat = 36.3504;
    var defaultHeight = 20000;

    var options = {
      mapId: 'vmap',
      initPosition: new vw.CameraPosition(
        new vw.CoordZ(defaultLon, defaultLat, 2000),
        new vw.Direction(0, -90, 0)
      ),
      logo: true,
      navigation: true
    };

    var newMap = new vw.Map();
    newMap.setOption(options);
    newMap.setMapId('vmap');
    newMap.setInitPosition(
      new vw.CameraPosition(
        new vw.CoordZ(defaultLon, defaultLat, defaultHeight),
        new vw.Direction(0, -90, 0)
      )
    );

    newMap.setLogoVisible(true);
    newMap.setNavigationZoomVisible(true);
    newMap.start();

    map = newMap;
    window.map = newMap;

    console.log('âœ… ì§€ë„ ìƒì„± ì™„ë£Œ!');
    setTimeout(attachClickHandler, 1000);
    return true;
  } catch (e) {
    console.error('ì§€ë„ ìƒì„± ì˜¤ë¥˜:', e);
    return false;
  }
}

function attachClickHandler() {
  var attempts = 0;
  var interval = setInterval(function() {
    attempts++;
    if (!map) map = window.map;

    if (map) {
      var attached = false;

      if (map.onClick && typeof map.onClick.addEventListener === 'function') {
        try { map.onClick.addEventListener(buildingInfoEvent); attached = true; }
        catch (e) { console.error('í´ë¦­ ì´ë²¤íŠ¸ ë¶€ì°© ì‹¤íŒ¨(onClick):', e); }
      } else if (typeof map.addEventListener === 'function') {
        try {
          var clickEvent = (vw && vw.EventType && vw.EventType.CLICK) ? vw.EventType.CLICK : 'click';
          map.addEventListener(clickEvent, buildingInfoEvent); attached = true;
        } catch (e) { console.error('í´ë¦­ ì´ë²¤íŠ¸ ë¶€ì°© ì‹¤íŒ¨(addEventListener):', e); }
      } else if (map.getEventManager && typeof map.getEventManager === 'function') {
        try {
          var manager = map.getEventManager();
          if (manager && typeof manager.addEventListener === 'function') {
            var managerClickEvent = (vw && vw.EventType && vw.EventType.CLICK) ? vw.EventType.CLICK : 'click';
            manager.addEventListener(managerClickEvent, buildingInfoEvent); attached = true;
          }
        } catch (e) { console.error('í´ë¦­ ì´ë²¤íŠ¸ ë¶€ì°© ì‹¤íŒ¨(eventManager):', e); }
      }

      if (attached) { clearInterval(interval); console.log('âœ… í´ë¦­ ì´ë²¤íŠ¸ ë¶€ì°© ì™„ë£Œ!'); return; }
    }

    if (attempts >= 50) { clearInterval(interval); console.error('í´ë¦­ í•¸ë“¤ëŸ¬ íƒ€ì„ì•„ì›ƒ'); }
  }, 200);
}

var buildingInfoEvent = function(windowPosition, ecefPosition, cartographic, modelObject) {
  try {
    if (!modelObject) return;
    if (DEBUG) {
      console.log('[buildingInfoEvent] modelObject:', modelObject);
    }
    const mapElement = modelObject.element || null;
    const feature = toFeatureCandidate(modelObject) || mapElement || null;
    const attributes = getFeatureAttributes(feature, modelObject.attributes);
    if (!mapElement && !feature) return;

    rememberSelection(mapElement, feature, attributes);
    applySelectionHighlight('ì •ë³´ ì—†ìŒ', feature);

    const sidebar = $id('mapSidebar');
    if (sidebar && !sidebar.classList.contains('open')) sidebar.classList.add('open');

    var coordsStr = formatCartographic(cartographic) || '';
    var numericCoords = extractLonLat(cartographic);
    var bIdVal = (attributes && (attributes.MODEL_NAME || attributes.__OID__ || attributes.TD_ID || attributes.ID)) || '';

    if (bIdVal !== _lastState.id || coordsStr !== _lastState.coords) {
      _lastState.id = bIdVal;
      _lastState.coords = coordsStr;

      ensureSidebarOpen();
      prepareSidebarForData(bIdVal);

      if (numericCoords && isFinite(numericCoords.lon) && isFinite(numericCoords.lat)) {
        requestRoadAddressAndData(numericCoords.lon, numericCoords.lat, bIdVal);
      }
    }
  } catch (e) {
    console.error('buildingInfoEvent error', e);
  }
};

function initMapSidebar() {
  const toggleBtn = $id('toggleMapSidebar');
  const sidebar = $id('mapSidebar');
  if (toggleBtn && sidebar) {
    toggleBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      sidebar.classList.toggle('open');
    });
  }
}

function initRegionSearch() {
  bindSearchControls('regionSearchInput', 'regionSearchBtn');
  bindSearchControls('mapSearchInput', 'mapSearchBtn');
}

function bindSearchControls(inputId, buttonId) {
  const inputEl = $id(inputId);
  const buttonEl = $id(buttonId);
  if (!inputEl || !buttonEl) return;

  const run = () => performRegionSearch(inputEl);
  buttonEl.type = 'button';
  buttonEl.addEventListener('click', run);
  inputEl.addEventListener('keydown', e => { if (e.key === 'Enter') run(); });
}

async function performRegionSearch(inputEl) {
  const keyword = (inputEl?.value || '').trim();
  if (!keyword) {
    alert('ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
    return;
  }
  await searchRegionAndDisplayResults(keyword);
}

async function searchRegionAndDisplayResults(keyword) {
  const targetMap = map || window.map;
  if (!targetMap) {
    alert('ì§€ë„ ì´ˆê¸°í™”ê°€ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
    return;
  }

  clearSearchMarkers();

  const addrParams = new URLSearchParams({
    query: keyword,
    size: '1',
    page: '1',
    type: 'address'
  });
  let items = await callVworldSearch(addrParams);

  if (!items || items.length === 0) {
    const poiParams = new URLSearchParams({
      query: keyword,
      size: '1',
      page: '1',
      type: 'place'
    });
    items = await callVworldSearch(poiParams);
  }

  if (!items || items.length === 0) {
    const fallbackItem = await fallbackGeocodeSearch(keyword);
    if (fallbackItem) {
      focusMapToSearchResult(targetMap, fallbackItem);
      presentSearchResult(fallbackItem, keyword);
      renderSearchMarkers(targetMap, [fallbackItem]);
      ensureSidebarOpen();
      return;
    }
    alert('ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    return;
  }

  items = dedupeByCoord(items, DEDUPE_EPS).slice(0, SEARCH_MAX_MARKERS);

  focusMapToSearchResult(targetMap, items[0]);
  presentSearchResult(items[0], keyword);
  renderSearchMarkers(targetMap, items);
  ensureSidebarOpen();
}

async function callVworldSearch(params) {
  try {
    const res = await fetch(`/api/search_address?${params.toString()}`);
    if (!res.ok) {
      console.warn('search_address HTTP ì˜¤ë¥˜', res.status);
      return [];
    }
    const json = await res.json();
    if (json?.response?.status === 'OK') {
      return json?.response?.result?.items || [];
    }
    if (json?.error) {
      console.warn('VWorld ê²€ìƒ‰ API ì—ëŸ¬:', json.error);
    }
  } catch (e) {
    console.error('VWorld ê²€ìƒ‰ í˜¸ì¶œ ì‹¤íŒ¨:', e);
  }
  return [];
}

function dedupeByCoord(items, eps) {
  const seen = [];
  const out = [];
  for (const it of items) {
    const x = Number(it?.point?.x);
    const y = Number(it?.point?.y);
    if (!isFinite(x) || !isFinite(y)) continue;
    let dup = false;
    for (const [sx, sy] of seen) {
      if (Math.abs(x - sx) <= eps && Math.abs(y - sy) <= eps) { dup = true; break; }
    }
    if (!dup) {
      seen.push([x, y]);
      out.push(it);
    }
  }
  return out;
}

function clearSearchMarkers() {
  if (Array.isArray(searchMarkers) && searchMarkers.length) {
    searchMarkers.forEach(m => { try { m?.destroy?.(); } catch(e){} });
  }
  searchMarkers = [];
}

function focusMapToSearchResult(targetMap, item) {
  if (!item?.point) return;
  const lon = Number(item.point.x);
  const lat = Number(item.point.y);
  if (!isFinite(lon) || !isFinite(lat)) return;

  const cameraPosition = new vw.CameraPosition(
    new vw.CoordZ(lon, lat, 1500),
    new vw.Direction(0, -90, 0)
  );
  if (typeof targetMap.moveTo === 'function') targetMap.moveTo(cameraPosition);

  const cam = targetMap.getCamera && targetMap.getCamera();
  if (cam?.setPositionAndRotation) cam.setPositionAndRotation(cameraPosition);

  map = targetMap;
}

function renderSearchMarkers(targetMap, items) {
  if (!Array.isArray(items)) return;

  items.forEach((item, i) => {
    const mx = Number(item.point?.x);
    const my = Number(item.point?.y);
    if (!isFinite(mx) || !isFinite(my)) return;

    const point = new vw.geom.Point(new vw.Coord(mx, my));

    point.setImage(SEARCH_MARKER_IMAGE + '?v=20251112', SEARCH_MARKER_SIZE.w, SEARCH_MARKER_SIZE.h);

    point.setName(item.title || `ê²€ìƒ‰ê²°ê³¼ ${i + 1}`);
    point.setId('search_marker_' + i);
    point.setFont('ê³ ë”•');
    point.setFontSize(14);

    const road = item.address?.road || item.address?.roadAddress || '';
    const parcel = item.address?.parcel || item.address?.parcelAddress || '';
    const full = item.address?.full || road || parcel || item.title || '';

    point.set('road', road);
    point.set('parcel', parcel);
    point.set('full', full);
    if (!item.address) item.address = {};
    if (!item.address.full) item.address.full = full;

    point.create();

    point.addEventListener((windowPosition, _ecef, _carto, featureInfo) => {
      if (!featureInfo) return;
      const markerObj = targetMap.getObjectById(featureInfo.groupId);
      if (!markerObj) return;

      const road = markerObj.get('road');
      const parcel = markerObj.get('parcel');
      const full = markerObj.get('full');
      const title = markerObj.getName();

      presentSearchResult({
        point: { x: mx, y: my },
        title,
        address: { road, parcel, full }
      }, title);
    });

    searchMarkers.push(point);
  });
}

function ensureSidebarOpen() {
  const sidebar = $id('mapSidebar');
  if (sidebar && !sidebar.classList.contains('open')) sidebar.classList.add('open');
}

function resetSidebarAdminFields() {
  const ageEl = $id('sidebar_age');
  const purposeEl = $id('sidebar_purpose');
  const heightEl = $id('sidebar_height');
  const structureEl = $id('sidebar_structure');
  const floorsEl = $id('sidebar_floors');

  if (ageEl) ageEl.textContent = '-';
  if (purposeEl) purposeEl.textContent = '-';
  if (heightEl) heightEl.textContent = '-';
  if (structureEl) structureEl.textContent = '-';
  if (floorsEl) floorsEl.textContent = '-';
}

function prepareSidebarForData() {
  requestAnimationFrame(function() {
    const addressEl = $id('sidebar_address');
    const ageEl = $id('sidebar_age');
    const purposeEl = $id('sidebar_purpose');
    const roadEl = $id('sidebar_road');

    if (addressEl) addressEl.textContent = 'ì¡°íšŒ ì¤‘...';
    if (ageEl) ageEl.textContent = 'ì¡°íšŒ ì¤‘...';
    if (purposeEl) purposeEl.textContent = 'ì¡°íšŒ ì¤‘...';
    if (roadEl) roadEl.textContent = '-';
  });
}

function presentSearchResult(item, keyword) {
  if (!item) return;

  const lon = Number(item?.point?.x);
  const lat = Number(item?.point?.y);
  if (!isFinite(lon) || !isFinite(lat)) return;

  const label = item?.title || keyword || 'ê²€ìƒ‰ ê²°ê³¼';
  ensureSidebarOpen();
  prepareSidebarForData();
  updateSidebarWithSearchItem(item, keyword);

  requestRoadAddressAndData(lon, lat, label);
}

function updateSidebarWithSearchItem(item, keyword) {
  const full = item?.address?.full || item?.title || keyword || '';

  const addressEl = $id('sidebar_address');
  if (addressEl && full) addressEl.textContent = full;

  const roadEl = $id('sidebar_road');
  if (roadEl) {
    const roadDetail = item?.address?.full || [item?.address?.road, item?.address?.parcel]
      .filter(Boolean)
      .join(' ');
    roadEl.textContent = roadDetail || '-';
  }
}

function buildSidebarDetail(structure, firstResult, fallback) {
  const parts = [];
  const push = v => {
    if (!v) return;
    const t = String(v).trim();
    if (t && !parts.includes(t)) parts.push(t);
  };

  const candidate = firstResult?.structure || {};
  push(structure?.level4L || structure?.level4LC || candidate.level4L || candidate.level4LC);
  push(structure?.level5 || candidate.level5);
  push(structure?.level6 || candidate.level6);
  push(structure?.detail || candidate.detail);
  push(firstResult?.detail);

  if (parts.length === 0 && fallback) push(fallback);
  return parts.join(' ').trim();
}

function updateSidebarWithAddress(response, fallbackRoadAddress) {
  const refined = response?.refined || {};
  const results = response?.result;
  const firstResult = Array.isArray(results) ? results[0] : results;
  const structure = refined.structure || firstResult?.structure || {};
  const fullText = refined.text || firstResult?.text || fallbackRoadAddress;

  const addressEl = $id('sidebar_address');
  if (addressEl) addressEl.textContent = fullText || fallbackRoadAddress || 'ì£¼ì†Œ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';

  const roadEl = $id('sidebar_road');
  if (roadEl) {
    const detail = buildSidebarDetail(structure, firstResult, fallbackRoadAddress);
    roadEl.textContent = detail || fullText || fallbackRoadAddress || '-';
  }
}

async function fallbackGeocodeSearch(keyword) {
  try {
    const params = new URLSearchParams({ query: keyword });
    const response = await fetch(`/api/geocode?${params.toString()}`);
    if (!response.ok) return null;

    const data = await response.json();
    if (data?.error) {
      console.warn('ì§€ì˜¤ì½”ë”© í”„ë¡ì‹œ ì˜¤ë¥˜:', data.error);
      return null;
    }

    const result = data?.response?.result;
    const first = Array.isArray(result) ? result[0] : result;
    if (!first?.point) return null;

    const lon = Number(first.point.x);
    const lat = Number(first.point.y);
    if (!isFinite(lon) || !isFinite(lat)) return null;

    const structure = first.structure || {};
    const road = structure.level4L || structure.level4LC || '';
    const parcel = structure.level5 || structure.level6 || '';
    const full = first.text || [road, parcel].filter(Boolean).join(' ') || keyword;

    return {
      point: { x: lon, y: lat },
      title: first.text || keyword,
      address: { road, parcel, full }
    };
  } catch (e) {
    console.error('Geocode fallback ì˜¤ë¥˜:', e);
    return null;
  }
}

function requestRoadAddressAndData(lon, lat, buildingId) {
  if (!lon || !lat) return;

  var url = `/api/get_address?lon=${Number(lon).toFixed(9)}&lat=${Number(lat).toFixed(9)}`;
  var requestId = ++_lastAddressRequestId;

  fetch(url)
    .then(res => res.ok ? res.json() : Promise.reject('HTTP ' + res.status))
    .then(data => {
      if (requestId !== _lastAddressRequestId) return;

      let roadAddress = '';
      const responsePayload = data && data.response;
      if (responsePayload && responsePayload.status === 'OK') {
        const result = responsePayload.result;
        if (Array.isArray(result) && result.length > 0) {
          const firstResult = result[0];
          roadAddress = firstResult.text || firstResult.structure?.text || '';
        } else if (result && typeof result === 'object') {
          roadAddress = result.text || '';
        }
      }

      const addressEl = $id('sidebar_address');
      if (addressEl) addressEl.textContent = roadAddress || 'ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';

      updateSidebarWithAddress(responsePayload, roadAddress);
      fetchBuildingData(lon, lat, buildingId);
    })
    .catch(err => {
      if (requestId !== _lastAddressRequestId) return;
      const addressEl = $id('sidebar_address');
      if (addressEl) addressEl.textContent = 'ì£¼ì†Œ ì¡°íšŒ ì‹¤íŒ¨';
      resetSidebarAdminFields();
    });
}

async function fetchBuildingData(lon, lat, buildingId) {
  try {
    const eproData = await fetchDataFromCoords(lon, lat);

    let eproAge = 'ì •ë³´ ì—†ìŒ';
    let eproPurpose = 'ì •ë³´ ì—†ìŒ';
    let eproHeight = 'ì •ë³´ ì—†ìŒ';
    let eproStructure = 'ì •ë³´ ì—†ìŒ';
    let eproFloors = 'ì •ë³´ ì—†ìŒ';
    let ageGroup = 'ì •ë³´ ì—†ìŒ';

    if (eproData) {
      const age = eproData.BULD_SPANU_NUM ?? eproData.AVG_AGE;
      const ageValue = normalizeAgeValue(age);
      if (ageValue != null) {
        eproAge = `${ageValue.toFixed(1)} ë…„`;
        ageGroup = getAgeGroup(ageValue);
      }
      eproPurpose = eproData.BILD_PRPOS || eproData.BUILDING_TYPE || 'ì •ë³´ ì—†ìŒ';
      eproHeight = eproData.BULD_HEIGHT ? `${eproData.BULD_HEIGHT} m` : 'ì •ë³´ ì—†ìŒ';
      eproStructure = eproData.STRCT_TY_NM || 'ì •ë³´ ì—†ìŒ';
      eproFloors = eproData.GRD_FLR_CNT ? `${eproData.GRD_FLR_CNT} ì¸µ` : 'ì •ë³´ ì—†ìŒ';
    }

    const ageEl = $id('sidebar_age');
    const purposeEl = $id('sidebar_purpose');
    const heightEl = $id('sidebar_height');
    const structureEl = $id('sidebar_structure');
    const floorsEl = $id('sidebar_floors');

    if (ageEl) ageEl.textContent = eproAge;
    if (purposeEl) purposeEl.textContent = eproPurpose;
    if (heightEl) heightEl.textContent = eproHeight;
    if (structureEl) structureEl.textContent = eproStructure;
    if (floorsEl) floorsEl.textContent = eproFloors;

    applySelectionHighlight(ageGroup);
  } catch (e) {
    console.error('fetchBuildingData error', e);
    const ageEl = $id('sidebar_age');
    const purposeEl = $id('sidebar_purpose');
    const heightEl = $id('sidebar_height');
    const structureEl = $id('sidebar_structure');
    const floorsEl = $id('sidebar_floors');

    if (ageEl) ageEl.textContent = 'ì •ë³´ ì—†ìŒ';
    if (purposeEl) purposeEl.textContent = 'ì •ë³´ ì—†ìŒ';
    if (heightEl) heightEl.textContent = 'ì •ë³´ ì—†ìŒ';
    if (structureEl) structureEl.textContent = 'ì •ë³´ ì—†ìŒ';
    if (floorsEl) floorsEl.textContent = 'ì •ë³´ ì—†ìŒ';

    applySelectionHighlight('ì •ë³´ ì—†ìŒ');
  }
}

async function fetchDataFromCoords(lon, lat) {
  try {
    const key = `${lon.toFixed(6)},${lat.toFixed(6)}`;
    if (_dataCache.has(key)) return _dataCache.get(key);

    const res = await fetch(`/api/get-data-from-coords?lon=${lon}&lat=${lat}`);
    if (!res.ok) return null;

    const json = await res.json();
    if (json.status === 'OK' && json.data) {
      _dataCache.set(key, json.data);
      return json.data;
    }
    return null;
  } catch (e) {
    return null;
  }
}

function debouncedHighlight(mapElement, attributes) {
  if (_highlightTimeout) clearTimeout(_highlightTimeout);
  _highlightTimeout = setTimeout(function() {
    try { if (mapElement && typeof mapElement.highlightFeatureByKey === 'function') mapElement.highlightFeatureByKey(attributes); }
    catch (e) {}
  }, _HIGHLIGHT_DELAY);
}

function formatCartographic(cartographic) {
  if (!cartographic) return '';
  var lon, lat, h;

  if (Array.isArray(cartographic)) { lon = cartographic[0]; lat = cartographic[1]; h = cartographic[2]; }
  else if (typeof cartographic === 'object') {
    lon = cartographic.longitude || cartographic.lon || cartographic.x;
    lat = cartographic.latitude || cartographic.lat || cartographic.y;
    h = cartographic.height || cartographic.z;
  }

  function toDegOrKeep(v) {
    if (v == null || !isFinite(v)) return null;
    return Math.abs(v) <= 2 * Math.PI ? (v * 180 / Math.PI).toFixed(6) : Number(v).toFixed(6);
  }

  var lonD = toDegOrKeep(lon);
  var latD = toDegOrKeep(lat);
  if (!lonD || !latD) return '';
  return lonD + ', ' + latD + (h ? (' (h:' + Number(h).toFixed(2) + ')') : '');
}

function extractLonLat(cartographic) {
  if (!cartographic) return null;
  var lon, lat, h;

  if (Array.isArray(cartographic)) { lon = cartographic[0]; lat = cartographic[1]; h = cartographic[2]; }
  else if (typeof cartographic === 'object') {
    lon = cartographic.longitude || cartographic.lon || cartographic.x;
    lat = cartographic.latitude || cartographic.lat || cartographic.y;
    h = cartographic.height || cartographic.z;
  }

  if (lon == null || lat == null) return null;

  function toDeg(v) {
    if (v == null || !isFinite(v)) return null;
    return Math.abs(v) <= 2 * Math.PI ? v * 180 / Math.PI : v;
  }

  return { lon: toDeg(lon), lat: toDeg(lat), height: (h != null && isFinite(h)) ? Number(h) : null };
}

window.addEventListener('load', function() {
  console.log('í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ');
  initMapSidebar();
  initRegionSearch();

  var attempts = 0;
  var interval = setInterval(function() {
    attempts++;
    if (typeof vw !== 'undefined' && typeof vw.Map === 'function') {
      clearInterval(interval);
      console.log('VWorld API ë¡œë“œ ì™„ë£Œ');
      setTimeout(function() { initializeMap(); }, 500);
    } else if (attempts >= 50) {
      clearInterval(interval);
      console.error('VWorld API ë¡œë“œ íƒ€ì„ì•„ì›ƒ');
      alert('ì§€ë„ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
    }
  }, 200);
});